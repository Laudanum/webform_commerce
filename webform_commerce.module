<?php
/**
 * @file
 * This is the file description for Webform Commerce module.
 *
 * In this more verbose, multi-line description, you can specify what this
 * file does exactly. Make sure to wrap your documentation in column 78 so
 * that the file can be displayed nicely in default-sized consoles.
 */

/**
 * Implements hook_webform_component_info
 */
function webform_commerce_webform_component_info() {
  $components = array();

  $components['commerce'] = array(
    'label' => t('Commerce payment'),
    'description' => t('Charges for webform submission.'),
    'features' => array(
      'conditional' => FALSE,
      'required' => FALSE,
      'title_display' => FALSE,
    ),
    'file' => 'webform_commerce.component.inc',
  );

  return $components;
}

/**
 * Implements hook_webform_component_info_alter().
 * 
 * Taken directly from webform_pay
 *
 */
function webform_commerce_webform_component_info_alter(&$components) {
  // Allow components of these types to be used as a price field.
  $components['textfield']['features']['price'] = TRUE;
  $components['select']['features']['price'] = TRUE;
  $components['hidden']['features']['price'] = TRUE;
}

/**
 * Implements hook_webform_component_presave().
 */
function webform_commerce_webform_component_presave(&$component) {
  // dsm($component);
  // Register a pay_form entry for this pay component.
  // if ($component['type'] == 'commerce') {
  //   $pfid = $component['extra']['pfid'];
  //   // $node = node_load($component['nid']);
  //   // $pay = pay_form_load($pfid ? $pfid : 'webform_pay');
  //   // $pay->uid = $node->uid;
  //   // $pay->title = $node->title;
  //   // $pay->menu_path = 'node/' . $node->nid;
  //   // $pay->pay_methods = array($pmid => $pmid);
  //   // $pay->save();
  // 
  //   // Update the component pay form ID.
  //   // $component['extra']['pfid'] = $pay->pfid;
  // }
}

/**
 * Implements hook_node_load().
 * 
 * Taken directly from webform_pay
 */
function webform_commerce_node_load($nodes, $types) {
  // Quick check to see if we need to do anything at all for these nodes.
  $webform_types = webform_variable_get('webform_node_types');
  if (count(array_intersect($types, $webform_types)) == 0) {
    return;
  }

  // Select all webforms that match these node IDs.
  $result = db_select('webform_component', 'wc')
    ->fields('wc', array('nid', 'cid'))
    ->condition('type', 'commerce')
    ->condition('nid', array_keys($nodes), 'IN')
    ->execute()
    ->fetchAllKeyed();

  foreach ($result as $nid => $cid) {
    $nodes[$nid]->webform_commerce_cid = $cid;
  }
  
}

/**
 * Implements hook_form_alter().
 * 
 * Inspired by from webform_pay
 */
function webform_commerce_form_alter(&$form, &$form_state, $form_id) {
  if (preg_match('/^webform_client_form_\d+$/', $form_id) && isset($form['#node']->webform_commerce_cid)) {

    $node = $form['#node'];

    $commerce_cid = $node->webform_commerce_cid;
    $component = $node->webform['components'][$commerce_cid];

    if ($product = commerce_product_load_by_sku($component['extra']['pricing']['product_to_add'])) {
      $amount = commerce_product_calculate_sell_price($product);
      $form_state['base_price'] = $amount;
    }

    $total = !isset($form_state['total']) ? $amount['amount'] : $form_state['total'];
    
    // Add a class to add positioning to the form
    $form['#attributes']['class'][] = 'commerce-webform';

    // Create the "Total:" and Line Item box
    if (empty($form['#submission']->sid)) {
      $form['cost'] = array(
        '#type' => 'container',
      );

      $form['cost']['title'] = array(
        '#type' => 'item',
        '#markup' => "<h2>Total: <span id='cost_heading'>" . commerce_currency_format($total, $amount['currency_code']) . "</span></h2>",
      );
      
      foreach ($component['extra']['pricing']['price_components'] as $cid => $enabled) {
        if ($enabled && isset($node->webform['components'][$cid])) {

          $price_component = $node->webform['components'][$cid];
          $parent_keys = webform_component_parent_keys($node, $price_component);
          
          foreach ($parent_keys as $form_key) {
            $title = $price_component['name'];
            $value = isset($form_state['cost']['options'][$form_key]) ? $form_state['cost']['options'][$form_key] : '0';

            $form['cost'][$form_key] = array(
              '#type' => 'item',
              '#markup' => "<p>" . $title . ": <span id='{$form_key}'>" . commerce_currency_format($value, 'USD') . "</span></p>",
            );

            // add ajax to each component that can alter price
            $form['submitted'][$form_key]['#attributes']['class'][] = 'ajax-fix';
            $form['submitted'][$form_key]['#ajax'] = array(
              'callback' => 'webform_commerce_price_adjust', 
              'progress' => array(
                'type' => 'throbber',
                'message' => NULL,
              ),
            );
          }
        }
      }
    }
    
    $form['#after_build'][] = 'webform_commerce_after_build';
    $form['#validate'][] = 'webform_commerce_validate';
    $form['#submit'][] = 'webform_commerce_submit';
  }
}

/**
 * Ajax callback to adjust the price display
 */
function webform_commerce_price_adjust(&$form, $form_state) {
  $commands = array();
  
  // Adjust the display of the main "Total"
  $amount = commerce_currency_format($form_state['total'], $form_state['base_price']['currency_code']);
  $commands[] = ajax_command_html("#cost_heading", $amount);

  // Adjust the display value of each line item
  $items = $form_state['cost']['options'];
  foreach($items as $k => $v) {
    $line_item_amount = commerce_currency_format($v, 'USD');
    $commands[] = ajax_command_html("#". $k, $line_item_amount);
  }

  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * After build function for webform_commerce_form_alter.
 *
 * Inspired by from webform_pay
 */
function webform_commerce_after_build($form) {
  $node = $form['#node'];
  $commerce_cid = $node->webform_commerce_cid;
  $component = $node->webform['components'][$commerce_cid];

  // If editing a submission, do NOT reprocess add to cart/validate functions.
  if (!empty($form['#submission']->sid)) {
    $submit_index = array_search('webform_commerce_submit', $form['#submit']);
    $validate_index = array_search('webform_commerce_validate', $form['#validate']);
    
    if ($submit_index !== FALSE) {
      unset($form['#submit'][$submit_index]);
    }
    if ($validate_index !== FALSE) {
      unset($form['#validate'][$validate_index]);
    }
  }

  return $form;
}

/**
 * Validation function for webforms that accept payment information.
 *
 * This is responsible for finding all the price fields within the webform and
 * adding up all the totals. Currently either textfields or select lists may
 * be used for prices.
 * 
 * Inspired by from webform_pay
 */
function webform_commerce_validate(&$form, &$form_state) {
  $node = $form['#node'];
  $commerce_cid = $node->webform_commerce_cid;
  $component = $node->webform['components'][$commerce_cid];

  // Add up all the components that contain price values.
  $total = $form_state['base_price']['amount'];
  
  foreach ($component['extra']['pricing']['price_components'] as $cid => $enabled) {
    if ($enabled && isset($node->webform['components'][$cid])) {
      $price_component = $node->webform['components'][$cid];
      
      // Find the price value if on the current page.
      $price_value = _webform_commerce_component_value($node, $price_component, $form_state['values']['submitted'], TRUE);
      
      // Find the price value from any previous pages.
      if ($price_value === FALSE && isset($form_state['storage']['submitted'])) {
        $price_value = _webform_commerce_component_value($node, $price_component, $form_state['storage']['submitted']);
      }
      
      $form_key = $price_component['form_key'];
      $form_state['cost']['options'][$form_key] = (float) $price_value * 100;
      
      $price_parents = webform_component_parent_keys($node, $price_component);
      if (!empty($price_value) && !is_numeric($price_value)) {
        form_set_error('submitted][' . implode('][', $price_parents), t('The value for @name needs to be a valid amount.', array('@name' => $price_component['name'])));
      }
      else {
        $total += (float) $price_value * 100;
      }
    }
  }
  
  $form_state['total'] = $total;
  
  // Set the total for the webform.
  $form_state['values']['webform_commerce']['total'] = $total;
  $form_state['values']['webform_commerce']['status'] = 'unpaid';
  
  // Drill down to the commerce form element.
  $parent_keys = webform_component_parent_keys($node, $component);
  $element = &$form['submitted'];
  foreach ($parent_keys as $form_key) {
    $element = &$element[$form_key];
  }
  
  if ($element) {
    // Set the component value so that it gets saved into the Webform table.
    form_set_value($element, $form_state['values']['webform_commerce'], $form_state);
  }
}

/**
 * Submit callback to add a product to the cart
 * This is taken straight from commerce_cart_add_to_cart_form_submit
 */

function webform_commerce_submit(&$form, &$form_state) {
  // Only submit the registration if the webform has been fully submitted
  if (!empty($form_state['values']['details']['sid'])) {
    global $user;
    // $product_id = $form_state['values']['product_id'];
    $product_id = '1';
    $quantity = '1';
    $combine = FALSE;
    
    if ($line_item = commerce_cart_product_add_by_id($product_id, $quantity, $combine, $user->uid)) {

      $new_line_item = my_special_function2($line_item->order_id);
      
      // Add the line item to the order using the wrapper.
      // Wrap the order to simplify manipulating its field data.
      $order = commerce_order_load($line_item->order_id);
      $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

      $order_wrapper->commerce_line_items[] = $new_line_item;

      // Save the order again to update its line item reference field.
      commerce_order_save($order);
      
      drupal_set_message(t('Congrats'), 'status');
    }
    else {
      drupal_set_message(t('%title could not be added to your cart.', array('%title' => $product->title)), 'error');
    }
  }
}

function my_special_function2($order_id) {
  // Create the new line item.
  $line_item = commerce_line_item_new('fee', $order_id);

  // Set the price component of the unit price.
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  
  // Other code to populate the $line_item...
  $line_item_wrapper->line_item_label = 'Gift Wrapping';
  $line_item_wrapper->quantity = 1;

  // Build the custom unit price array.
  $unit_price = array(
    'amount' => (float) '13000',
    'currency_code' => commerce_default_currency(),
    'data' => array(),
  );
  
  $line_item_wrapper->commerce_unit_price->data = commerce_price_component_add(
    $unit_price,
    'base_price',
    $unit_price,
    TRUE
  );

  // Save the incoming line item now so we get its ID.
  commerce_line_item_save($line_item);
  
  return $line_item;
}

/**
 * Helper function to return the value of a component if it exists.
 *
 * @param $node
 *   The Webform node.
 * @param $component
 *   The Webform component to check for.
 * @param $values
 *   An array of webform values keyed by component ID.
 * @param $nested_tree
 *   Whether or not this function should treat the $values parameter as a tree.
 *   On same-page validation the form value is in a tree. On multiple page forms
 *   or on submission, the values are flattened by Webform.
 *
 * @return
 *   The submitted value of the component, or FALSE if the component was not
 *   contained in $values.
 */
function _webform_commerce_component_value($node, $component, $values, $nested_tree = FALSE) {
  $component_value = FALSE;
  if ($nested_tree) {
    $parent_keys = webform_component_parent_keys($node, $component);
    $component_value = $values;
    foreach ($parent_keys as $form_key) {
      if (isset($component_value[$form_key])) {
        $component_value = $component_value[$form_key];
      }
      else {
        $component_value = FALSE;
        break;
      }
    }
  }
  else {
    $cid = $component['cid'];
    $component_value = isset($values[$cid]) ? $values[$cid] : FALSE;
  }

  return $component_value;
}
